# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_math.ipynb.

# %% auto 0
__all__ = ['comb', 'binom', 'Wilson_var', 'Wald_var']

# %% ../nbs/01_math.ipynb 3
import numpy as np
from scipy.special import factorial

# %% ../nbs/01_math.ipynb 4
def comb(n, k):
    """Vectorized combination"""
    return factorial(n) / (factorial(k) * factorial(n-k))

# %% ../nbs/01_math.ipynb 5
def binom(k, n, p):
    """Vectorized binomial function"""
    k, n, p = np.array(k), np.array(n), np.array(p)
    return comb(n,k) * p**k * (1-p)**(n-k)

# %% ../nbs/01_math.ipynb 6
def Wilson_var(p, N, z=1.96):
    """Wilson estimator of binomial variance"""
    return z**2 * (p*(1-p)/N + z**2/(4*N**2)) / (1+z**2/N)**2

#hide
# We arrive at the Wilson var from :
# `wilson_max = (p + z**2/(2*N) + z*np.sqrt(p*(1-p)/N+z**2/(4*N**2)))/(1+z**2/N)`
# `wilson_min = (p + z**2/(2*N) - z*np.sqrt(p*(1-p)/N+z**2/(4*N**2)))/(1+z**2/N)`
# `return (wilson_max - wilson_min) / 2 # assume symmetric C.I. => take std as half.`

# %% ../nbs/01_math.ipynb 7
def Wald_var(p, N):
    """Wald estimator of binomial variance (known issues, better use Wilson)"""
    return p * (1-p) / N
