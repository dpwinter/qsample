# AUTOGENERATED! DO NOT EDIT! File to edit: 06b_sampler.base.ipynb (unless otherwise specified).

__all__ = ['tomatrix', 'err_probs_tomatrix', 'sort_by_list', 'subset_occurence', 'all_subsets', 'protocol_all_subsets',
           'protocol_subset_occurence', 'tolists', 'lens', 'maxlen', 'pad', 'Sampler']

# Cell
from .tree import CountTree, Variable, Constant

from ..callbacks import CallbackList
from tqdm.auto import tqdm
import itertools as it
import numpy as np
import qsam.math as math
from ..noise import E0
import dill as pickle

from collections.abc import Iterable

# Cell
tolists = lambda l: [e if isinstance(e,Iterable) else [e] for e in l]
lens = lambda list_of_lists: list(map(len,list_of_lists))
maxlen = lambda list_of_lists: max(lens(list_of_lists))
pad = lambda l,targ_len: np.append(l, [l[-1]] * (targ_len - len(l)))

def tomatrix(mixed_list):
    list_of_lists = tolists(mixed_list)
    return [pad(e,maxlen(list_of_lists)) for e in list_of_lists]

def err_probs_tomatrix(err_probs: dict, groups: list) -> np.ndarray:
    err_probs = sort_by_list(err_probs, groups)
    return np.array(tomatrix(err_probs.values())).T

def sort_by_list(d: dict, l: list) -> dict:
    return dict(sorted(d.items(), key=lambda pair: l.index(pair[0])))

def subset_occurence(groups, subsets, group_prob_range):
    Aws = [math.binom(subset, lens(groups), group_prob_range) for subset in subsets]
    return np.product(Aws, axis=-1)

def all_subsets(groups):
    return list(it.product( *[tuple(range(N+1)) for N in lens(groups)]))

def protocol_all_subsets(protocol_groups):
    return {cid: all_subsets(groups_dict.values()) for cid,groups_dict in protocol_groups.items()}

def protocol_subset_occurence(protocol_groups, protocol_subsets, group_probs):
    return {cid: {subset: Aw for subset, Aw in zip(subsets, subset_occurence(protocol_groups[cid].values(),subsets,group_probs))}
                  for cid,subsets in protocol_subsets.items()}

# Cell
class Sampler:

    def __init__(self, protocol, simulator, err_probs={"0":{}}, err_model=None):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = protocol.n_qubits
        self.err_model = err_model() if err_model else E0()

        self.protocol_groups = {cid: self.err_model.group(circuit) for cid, circuit in self.protocol._circuits.items()}
        self.protocol_subsets = protocol_all_subsets(self.protocol_groups)

        assert isinstance(err_probs, dict)
        assert set(err_probs.keys()) == set(self.err_model.groups)
        self.trees = dict()
        for prob_vec in err_probs_tomatrix(err_probs, self.err_model.groups):
            tree = CountTree(min_path_weight=2 if self.protocol.fault_tolerant else 1)
            tree.constants = protocol_subset_occurence(self.protocol_groups, self.protocol_subsets, prob_vec)
            self.trees[tuple(prob_vec)] = tree

    def save(self, path):
        with open(path, 'wb') as fp:
            pickle.dump(self, fp)

    @staticmethod
    def load(path):
        with open(path, 'rb') as fp:
            res = pickle.load(fp)
        return res

    def optimize(self, tree_node, circuit):
        """Must be overwritten by child class."""
        raise NotImplemented

    def run(self, n_samples: int, callbacks=[]) -> None:

        if not isinstance(callbacks, CallbackList):
            callbacks = CallbackList(sampler=self, callbacks=callbacks)
        callbacks.on_sampler_begin()

        for prob_vec, tree in self.trees.items():
            self.stop_sampling = False
            self.tree_idx = prob_vec

            for _ in tqdm(range(n_samples), desc=f'p_phy={",".join(list(f"{p:.2E}" for p in prob_vec))}', leave=True):
                callbacks.on_protocol_begin()

                state = self.simulator(self.n_qubits)
                tree_node = None

                for name, circuit in self.protocol:
                    callbacks.on_circuit_begin()

                    tree_node = tree.add(name=name, parent=tree_node, nodetype=Variable)
                    tree_node.counts += 1
                    opt_out = dict()

                    if circuit:
                        if not circuit._noisy:
                            msmt = state.run(circuit)
                        else:
                            opt_out = self.optimize(tree_node, circuit, prob_vec)
                            tree_node = tree.add(name=opt_out['subset'], parent=tree_node, nodetype=Constant, cid=circuit.id,
                                                 is_deterministic=True if circuit._ff_det and not any(opt_out['subset']) else False)
                            tree_node.counts += 1
                            fault_circuit = self.err_model.run(circuit, opt_out['flocs'])

                            msmt = state.run(circuit, fault_circuit)
                        self.protocol.send(msmt)

                    elif name != None:
                        tree_node.marked = True

                    callbacks.on_circuit_end(locals() | opt_out)

                callbacks.on_protocol_end()
                if self.stop_sampling: break

        callbacks.on_sampler_end()